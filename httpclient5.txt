import org.apache.hc.client5.http.config.ConnectionConfig;
import org.apache.hc.client5.http.config.RequestConfig;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClientBuilder;
import org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager;
import org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManagerBuilder;
import org.apache.hc.client5.http.ssl.SSLConnectionSocketFactory;
import org.apache.hc.client5.http.ssl.SSLConnectionSocketFactoryBuilder;
import org.apache.hc.core.util.Timeout;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;

/**
 * Production-grade Spring Boot configuration for a RestTemplate using Apache HttpClient 5.
 *
 * This configuration is meticulously crafted using the latest, non-deprecated APIs
 * and establishes a secure, efficient, and resilient HTTP client.
 *
 * Key Features:
 * - Modern API Usage: Exclusively uses the current builder patterns from HttpClient 5.3+.
 * - Secure by Default: Explicitly configures TLSv1.3 and TLSv1.2 as the only supported protocols.
 * - Efficient Connection Pooling: Configures a connection pool for high-throughput scenarios.
 * - Robust Timeouts: Sets sensible connection, response, and connection lease timeouts.
 * - Custom TrustStore Example: Includes a commented-out section showing how to load a custom TrustStore.
 */
@Configuration
public class RestTemplateConfiguration {

    // --- Sensible Defaults for Timeouts and Pooling ---

    /**
     * Timeout for establishing a connection with the server.
     */
    private static final Timeout CONNECT_TIMEOUT = Timeout.ofSeconds(5);

    /**
     * Timeout for receiving a response from the server after a connection is established.
     * Also known as the socket timeout.
     */
    private static final Timeout RESPONSE_TIMEOUT = Timeout.ofSeconds(10);

    /**
     * Timeout for requesting a connection from the connection manager's pool.
     */
    private static final Timeout CONNECTION_REQUEST_TIMEOUT = Timeout.ofSeconds(5);

    /**
     * Maximum total number of connections in the pool.
     */
    private static final int MAX_TOTAL_CONNECTIONS = 100;

    /**
     * Maximum number of connections per single route (hostname).
     */
    private static final int MAX_CONNECTIONS_PER_ROUTE = 20;


    /**
     * Creates the core PoolingHttpClientConnectionManager.
     * This is the heart of the client, managing a pool of persistent connections.
     * This implementation is security-focused, enabling only modern TLS protocols.
     *
     * @return A fully configured PoolingHttpClientConnectionManager.
     */
    @Bean
    public PoolingHttpClientConnectionManager poolingHttpClientConnectionManager() {
        // Create an SSLConnectionSocketFactory with explicit TLSv1.3 and TLSv1.2 support.
        // This is the modern, secure way to configure TLS.
        SSLConnectionSocketFactory sslSocketFactory = SSLConnectionSocketFactoryBuilder.create()
                .useSystemProperties() // Uses the JVM's default security settings which is often a good starting point.
                .setSupportedProtocols("TLSv1.3", "TLSv1.2")
                // See commented out method below for using a custom TrustStore
                // .setSslContext(createCustomSslContext()) 
                .build();

        // Use the PoolingHttpClientConnectionManagerBuilder for modern, fluent configuration.
        return PoolingHttpClientConnectionManagerBuilder.create()
                .setSSLSocketFactory(sslSocketFactory)
                .setMaxConnTotal(MAX_TOTAL_CONNECTIONS)
                .setMaxConnPerRoute(MAX_CONNECTIONS_PER_ROUTE)
                .setDefaultConnectionConfig(ConnectionConfig.custom()
                        .setConnectTimeout(CONNECT_TIMEOUT)
                        .setSocketTimeout(RESPONSE_TIMEOUT)
                        .build())
                .build();
    }

    /**
     * Creates the main CloseableHttpClient bean, which is the executable client.
     *
     * @param connectionManager The connection manager bean.
     * @return A configured CloseableHttpClient.
     */
    @Bean
    public CloseableHttpClient httpClient(PoolingHttpClientConnectionManager connectionManager) {
        // Configure default request settings.
        RequestConfig defaultRequestConfig = RequestConfig.custom()
                .setConnectionRequestTimeout(CONNECTION_REQUEST_TIMEOUT)
                .build();

        // Use the HttpClientBuilder for modern, fluent configuration.
        return HttpClientBuilder.create()
                .setConnectionManager(connectionManager)
                .setDefaultRequestConfig(defaultRequestConfig)
                .build();
    }

    /**
     * Creates the RestTemplate bean, the primary Spring abstraction for client-side HTTP calls.
     *
     * @param httpClient The fully configured CloseableHttpClient.
     * @return A RestTemplate instance ready for use.
     */
    @Bean
    public RestTemplate restTemplate(CloseableHttpClient httpClient) {
        // HttpComponentsClientHttpRequestFactory is the bridge between RestTemplate and Apache HttpClient.
        ClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);
        return new RestTemplate(requestFactory);
    }
    
    /**
     * [OPTIONAL] Example of creating a custom SSLContext that trusts a specific TrustStore.
     * This is useful when you need to connect to internal services with self-signed certificates.
     * To use this, uncomment the `.setSslContext(...)` call in the connection manager bean.
     *
     * @return A custom SSLContext.
     */
    private SSLContext createCustomSslContext() {
        try {
            // Load the custom TrustStore file.
            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
            try (FileInputStream instream = new FileInputStream("/path/to/your/truststore.jks")) {
                trustStore.load(instream, "your-truststore-password".toCharArray());
            }

            // Create a TrustManager that trusts the CAs in our TrustStore.
            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            trustManagerFactory.init(trustStore);

            // Create an SSLContext that uses our TrustManager.
            SSLContext sslContext = SSLContext.getInstance("TLSv1.3");
            sslContext.init(null, trustManagerFactory.getTrustManagers(), null);
            return sslContext;

        } catch (KeyStoreException | IOException | NoSuchAlgorithmException | CertificateException | KeyManagementException e) {
            // In a real application, proper logging and error handling are critical.
            throw new RuntimeException("Failed to create custom SSL context", e);
        }
    }
}
