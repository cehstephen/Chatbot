import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManagerBuilder;
import org.apache.hc.client5.http.ssl.NoopHostnameVerifier;
import org.apache.hc.client5.http.ssl.SSLConnectionSocketFactory;
import org.apache.hc.client5.http.ssl.TrustAllStrategy;
import org.apache.hc.core.ssl.SSLContextBuilder;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

import javax.net.ssl.SSLContext;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;

/**
 * RestTemplate configuration for Spring Boot 3 and Java 17 using Apache HttpClient 5.
 *
 * <p><b>*** EXTREMELY IMPORTANT SECURITY WARNING ***</b></p>
 * <p>This configuration creates a RestTemplate that <b>DISABLES ALL SSL/TLS CERTIFICATE VALIDATION</b>.
 * It will trust any certificate presented by any server and will not verify the hostname.
 * This is functionally equivalent to the configuration you provided from your old application.</p>
 *
 * <p><b>DO NOT USE THIS IN A PRODUCTION ENVIRONMENT.</b> It exposes your application to
 * Man-in-the-Middle (MITM) attacks. This should only be used for local development or when
 * communicating with a trusted internal service that uses self-signed certificates.</p>
 */
@Configuration
public class RestTemplateConfiguration {

    /**
     * Creates a RestTemplate bean configured to bypass all SSL security checks.
     * This version uses a more streamlined approach to building the underlying HttpClient.
     *
     * @param builder The RestTemplateBuilder injected by Spring Boot.
     * @return A configured RestTemplate instance.
     */
    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        try {
            // 1. Create an SSLContext that uses the "TrustAllStrategy".
            // This is a built-in HttpClient 5 strategy to simplify trusting all certificates.
            final SSLContext sslContext = new SSLContextBuilder()
                    .loadTrustMaterial(null, new TrustAllStrategy())
                    .build();

            // 2. Create a custom SSLConnectionSocketFactory using our insecure SSLContext.
            // We also disable hostname verification.
            final SSLConnectionSocketFactory sslSocketFactory = new SSLConnectionSocketFactory(
                sslContext,
                NoopHostnameVerifier.INSTANCE // Disables hostname verification
            );

            // 3. Build the CloseableHttpClient using the custom SSL factory.
            final CloseableHttpClient httpClient = HttpClients.custom()
                .setConnectionManager(
                    PoolingHttpClientConnectionManagerBuilder.create()
                        .setSSLSocketFactory(sslSocketFactory)
                        .build()
                )
                .build();
            
            // 4. Create the request factory using the custom http client.
            final HttpComponentsClientHttpRequestFactory customRequestFactory = new HttpComponentsClientHttpRequestFactory();
            customRequestFactory.setHttpClient(httpClient);

            // 5. Build the RestTemplate using the builder and our custom request factory.
            return builder
                    .requestFactory(() -> customRequestFactory)
                    .build();

        } catch (NoSuchAlgorithmException | KeyStoreException | KeyManagementException e) {
            // In a real app, you would want to log this error properly.
            throw new RuntimeException("Failed to create insecure RestTemplate", e);
        }
    }
