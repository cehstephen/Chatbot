import org.apache.hc.client5.http.config.RequestConfig;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClientBuilder;
import org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager;
import org.apache.hc.client5.http.socket.ConnectionSocketFactory;
import org.apache.hc.client5.http.socket.PlainConnectionSocketFactory;
import org.apache.hc.client5.http.ssl.SSLConnectionSocketFactory;
import org.apache.hc.client5.http.ssl.SSLContexts;
import org.apache.hc.core.http.config.Registry;
import org.apache.hc.core.http.config.RegistryBuilder;
import org.apache.hc.core.util.Timeout;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

import javax.net.ssl.SSLContext;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;

/**
 * Spring Boot configuration class for creating a RestTemplate bean.
 * This configuration uses Apache HttpClient 5 as the underlying HTTP transport layer,
 * which provides advanced features like connection pooling and sophisticated request configuration.
 *
 * This version is explicitly configured for secure connections over TLS (HTTPS).
 */
@Configuration
public class RestTemplateConfiguration {

    // --- Configuration Constants ---

    private static final int MAX_TOTAL_CONNECTIONS = 100;
    private static final int MAX_CONNECTIONS_PER_ROUTE = 20;
    private static final Timeout CONNECT_TIMEOUT = Timeout.ofSeconds(5);
    private static final Timeout RESPONSE_TIMEOUT = Timeout.ofSeconds(10);
    private static final Timeout CONNECTION_REQUEST_TIMEOUT = Timeout.ofSeconds(5);

    /**
     * Creates and configures the connection manager for the HttpClient.
     * This connection manager pools connections and is configured to handle both
     * HTTP and HTTPS connections, using a secure SSL Context for the latter.
     *
     * @return A configured PoolingHttpClientConnectionManager instance.
     */
    @Bean
    public PoolingHttpClientConnectionManager poolingHttpClientConnectionManager() {
        try {
            // Create a default SSLContext that trusts the certificates in the JVM's default trust store.
            SSLContext sslContext = SSLContexts.createDefault();

            // Create a socket factory for SSL connections.
            // This factory will use the default SSLContext and default hostname verifier.
            SSLConnectionSocketFactory sslSocketFactory = new SSLConnectionSocketFactory(sslContext);

            // Create a registry of socket factories, mapping schemes to their respective factories.
            // This allows the connection manager to handle both "http" and "https" schemes.
            Registry<ConnectionSocketFactory> socketFactoryRegistry = RegistryBuilder.<ConnectionSocketFactory>create()
                    .register("https", sslSocketFactory)
                    .register("http", new PlainConnectionSocketFactory())
                    .build();

            // Create a new connection manager with the custom socket factory registry.
            PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(socketFactoryRegistry);
            connectionManager.setMaxTotal(MAX_TOTAL_CONNECTIONS);
            connectionManager.setDefaultMaxPerRoute(MAX_CONNECTIONS_PER_ROUTE);
            return connectionManager;
        } catch (NoSuchAlgorithmException | KeyManagementException e) {
            // In a production app, you'd want to log this exception properly.
            // Failing to create the SSL context is a critical failure.
            throw new RuntimeException("Failed to create SSL context for HttpClient", e);
        }
    }

    /**
     * Configures the default request settings for all HTTP requests made by the client.
     * This includes setting various timeouts to prevent operations from blocking indefinitely.
     *
     * @return A configured RequestConfig instance.
     */
    @Bean
    public RequestConfig requestConfig() {
        return RequestConfig.custom()
                .setConnectionRequestTimeout(CONNECTION_REQUEST_TIMEOUT)
                .setConnectTimeout(CONNECT_TIMEOUT)
                .setResponseTimeout(RESPONSE_TIMEOUT)
                .build();
    }

    /**
     * Creates the main CloseableHttpClient bean.
     * This client is built with the SSL-enabled connection manager and default request configuration.
     * It is the core component that executes HTTP requests.
     *
     * @param connectionManager The connection manager to use.
     * @param requestConfig The default request configuration.
     * @return A configured CloseableHttpClient instance.
     */
    @Bean
    public CloseableHttpClient httpClient(PoolingHttpClientConnectionManager connectionManager, RequestConfig requestConfig) {
        return HttpClientBuilder.create()
                .setConnectionManager(connectionManager)
                .setDefaultRequestConfig(requestConfig)
                .build();
    }

    /**
     * Creates the RestTemplate bean.
     * This is the central Spring class for client-side HTTP access. It is configured
     * to use the HttpComponentsClientHttpRequestFactory, which in turn uses our
     * custom-configured Apache HttpClient 5.
     *
     * @param httpClient The underlying CloseableHttpClient.
     * @return A configured RestTemplate instance.
     */
    @Bean
    public RestTemplate restTemplate(CloseableHttpClient httpClient) {
        ClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);
        return new RestTemplate(requestFactory);
    }
}
